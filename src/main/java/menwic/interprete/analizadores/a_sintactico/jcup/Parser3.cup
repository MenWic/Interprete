package menwic.interprete.analizadores.a_sintactico;

import menwic.interprete.analizadores.a_lexico.Lexer;
import java.util.ArrayList;
import javax.swing.JOptionPane;
import java_cup.runtime.*;

//class Parser;
parser code {:

    //Heap que almacena variables
    private ArrayList<Variable> arrVariables; //Heap que almacena variables
    private ArrayList<String> arrProcedimientos; //Heap que almacena Procedimientos
    private ArrayList<String> arrFunciones; //Heap que almacena Funciones
    String txtFunciones = "";
    //private javax.swing.JTextArea textArea;

    //Constructor
    public parser(Lexer lex, javax.swing.JTextArea text){ //Debo cambiar TextArea por clase Codigo? Yo consideor que no
        super(lex);
        this.arrVariables = new ArrayList<>(); //Arreglo
        this.arrProcedimientos = new ArrayList<>(); //Arreglo de los nombres de procedimientos
        this.arrFunciones = new ArrayList<>(); //Arreglo de los nombres de funciones
        //this.txtFunciones = "";
    }
     
        String texto = ""; //Texto que iremos acumulando para pasar a Java

        //Getter de txt
        public String getText() {
                return texto;
        }

        //Getter de txt
        public String getTxtFunciones() {
                return txtFunciones;
        }
        
        public void syntax_error(Symbol cur_token){
            JOptionPane.showMessageDialog(null, "Error, Fila: "+ cur_token.left + ", Columna: " + cur_token.right + ", Lexema: " + cur_token.value.toString());
            //System.out.println("Error: "+ cur_token.left + "," + cur_token.right);
        }
        

        public void unrecoveres_syntax_error(Symbol cur_token){
            if(cur_token.sym==sym.EOF){
                System.out.println("Public void unrecoveredsyntax_Error");
            }
        }
        

        //Metodo que recorre el arreglo de casos de un Switch
        public String recorrerArrCasos(ArrayList<String> casos){
                String txt = "";
                for(String s : casos){
                        txt += s + "\n";
                }
                return txt;
        }

        //Metodo que recorre el arreglo de instrucciones de una ejecucion (condicion, ciclo o proceso)
        public String recorrerArrInstrucciones(ArrayList<String> instrucciones){
                String txt = "";
                for(String s : instrucciones){
                        txt += s + "\n";
                }
                return txt;
        }

        //Metodo para guardar variable al declararla
        public void guardarVariable(String dataType, String nameVar){
                arrVariables.add(new Variable(dataType,nameVar));
        }

        //Metodo para identificar tipo primitivo de la variable
        public String obtenerTipoVariable(String nameVar) {
                String resultado = "";
                Variable var = buscarVariable(nameVar);

                if (var != null) {
                        switch (var.getTipo()) {
                                case "int":
                                        return "int";
                                case "float":
                                        return "float";
                                case "String":
                                        return "String";
                        }
                } else {
                        System.out.println(var.getNombre() + " no fue encontrado como Variable.");
        }
        return resultado;
    }

        //Metodo para encontrar una variable declarada previamente
        public Variable buscarVariable(String nameVar){
                for(Variable var : arrVariables){
                        if(var.getNombre().equals(nameVar)){
                                return var;
                        }
                }
                return null;
        }

        /* ************************************************************************************************ */
        //Recorre parametros del arreglo global y elimina "_"
        public String recorrerParametros(ArrayList<String> arrParametros){
            String result = "";

            for(String p: arrParametros){
                result += p.replaceAll("_", " "); 
            }
            return result;
        }

        //Metodo para guardar procedimientos (nombre y parametros)
        public void guardarProcedimiento(String nameProcedure){
                arrProcedimientos.add(nameProcedure); //
        }

        //Metodo para guardar funciones (nombre, tipo, parametros)
        public void guardarFuncion(String dataType, String nameFunction){ //COMO HAGO POR EL TIPO, CONCATENADOS COMO UN STR???
                String func = dataType +"_"+ nameFunction;
                arrFunciones.add(func);
        }

        //Metodo para recorrer parametros enviados en llamda de funcion
        public String recorrerArrParametrosEnviados(ArrayList<String> arrParametrosEnviados) {
                String result = "";

                for (String pe: arrParametrosEnviados) {
                        result += pe;
                } 
                return result;
        }

        //Metodo para identificar tipo primitivo de la funcion
        //SIN USAR AUN, BORRAR
        /*
        public String obtenerTipoFuncion(String nameFunction) {
                String resultado = "";
                Funcion funct = buscarFunction(nameFunction);

                if (funct != null) {
                        switch (funct.getTipo()) {
                                case "int":
                                        return "int";
                                case "float":
                                        return "float";
                                case "String":
                                        return "String";
                        }
                } else {
                        System.out.println(var.getNombre() + " no fue encontrado como Funcion.");
            }
            return resultado;
        }
        /*
        /* ************************************************************************************************ */
:}


//terminals de flex
terminal IGUAL,MAS, MENOS, POR, DIV, DIF, MAYOR, MENOR, PAR_A, PAR_C, LLAVE_A, LLAVE_C, COMA, PUNTO_COMA, DOS_PUNTOS,
ENTERO, FLOTANTE, TEXTO, NumEntero, NumDecimal, NomVariable, Cadena, ESCRIBIR, LEER, SI, SINO, EN_CASO_DE, CASO, FIN_CASO, 
DEPLANO, PARA, MIENTRAS, PROCEDIMIENTO, FUNCION, RETORNA, ERROR;

//no terminales de cup
non terminal inicio, preejecucion, proceso, proced, param, funcion, tipoDato, retorno, ejecucion, tarea, principales, declaracion, asignacion, numero, operacion, operando, 
escritura, mensaje, lectura, llamada, parametro_enviado, condicionales, si, condicion, valor, comparador, sino, conmutador, numerocadena, caso, predeterminado,
ciclos, mientras, para, param_para;

non terminal ArrayList<String> parametros, parametros_enviados, casos, instruc; //no terminales de tipo ArrayList<String> para alamacenar Strings

        //Funciones/Procedimientos y Principales (ciclos,condicionales,principales) 
/*-0-*/inicio ::= preejecucion ejecucion {:  :}
                | ejecucion {:  :}
                ;


        //Funciones/Procedimientos recursivamente DUDA: ESTA BIEN ASI LA RECURSIVIDAD? O ES AL REVES?
/*-1-*/preejecucion ::= proceso preejecucion {:  :} //preejecucion
                    | proceso {:  :}
                    ;


        //No terminal: Procedimiento o Funcion
/*1)*/proceso ::= proced:p {: txtFunciones += p.toString() + "\n"; System.out.println(txtFunciones); :}
                | funcion:func {: txtFunciones += func.toString() + "\n"; :}
                ;

        //DUDA: los parametros:params cuando los guardo?
        
/*1*/proced ::= PROCEDIMIENTO NomVariable:nameProced PAR_A parametros:params PAR_C LLAVE_A instruc:instr LLAVE_C {:  guardarProcedimiento(nameProced.toString()); RESULT = "public static void " + nameProced.toString() + "(" + recorrerParametros(params) + "){" + recorrerArrInstrucciones(instr) + "}"; :}
                    | PROCEDIMIENTO NomVariable:nameProced PAR_A PAR_C LLAVE_A instruc:instr LLAVE_C {:  guardarProcedimiento(nameProced.toString()); RESULT = "public static void " + nameProced.toString() + "(){" + recorrerArrInstrucciones(instr) + "}"; :}
                    ;

        //No terminal: Funcion con y sin parametros
/*2*/funcion ::= FUNCION tipoDato:dataType NomVariable:nameFunc PAR_A parametros:params PAR_C LLAVE_A instruc:instr retorno:ret PUNTO_COMA LLAVE_C {: guardarFuncion(dataType.toString(), nameFunc.toString()); RESULT = "public static " + dataType.toString() + " " + nameFunc.toString() + "(" + recorrerParametros(params) + "){" + recorrerArrInstrucciones(instr) + ret.toString() + ";}"; :}
            | FUNCION tipoDato:dataType NomVariable:nameFunc PAR_A PAR_C LLAVE_A instruc:instr retorno:ret PUNTO_COMA LLAVE_C {: guardarFuncion(dataType.toString(), nameFunc.toString()); RESULT = "public static " + dataType.toString() + " " + nameFunc.toString() + "(){" + recorrerArrInstrucciones(instr) + ret.toString() + ";}"; :}
            ;

        //No terminal: ArrayList<params>
    parametros ::= param:par {: RESULT = new ArrayList<>(); RESULT.add(par.toString()); :}
                | parametros:pars COMA param:par {: pars.add(","+ par.toString()); RESULT = pars; :} 
                ;

    //No terminal: param (singular) que se guardara arriba en arrParametros (ArrayList<params>)
    param ::=  tipoDato:dataType NomVariable:nameProcedure  {: RESULT = dataType.toString() + "_" + nameProcedure.toString(); :}
           ;

    retorno ::= RETORNA NomVariable:var {: buscarVariable(var.toString()); RESULT =  "return " + var.toString(); :}
                | RETORNA numerocadena:numchain {: RESULT = "return " + numchain.toString(); :}
                | RETORNA NumDecimal:flot {: RESULT = "return " + flot.toString(); :}
                ;


    //DEBEN IR CONCATENADOS EL TIPO Y NOMBRE FUNC PARA GUARDAR EN ARRAYLIST??? 
    tipoDato ::= ENTERO {: RESULT = "int"; :}
            | FLOTANTE {: RESULT = "double"; :}
            | TEXTO {: RESULT = "String"; :}
            ;


        //No terminal: principales, condiciones o ciclos
/*-2-*/ejecucion ::= ejecucion tarea:task {: texto += task.toString(); :} //No mover recursividad xD
                    | tarea:task {: texto += task.toString(); :}
                    ;


/*-2.1-*/tarea ::= principales:princ PUNTO_COMA {: RESULT = princ.toString() + "\n"; :}
                    | condicionales:cond {: RESULT = cond.toString() + "\n"; :}
                    | ciclos:cycle {: RESULT = cycle.toString() + "\n"; :}
                    ;

        //No terminal: declara, asigna, escribe, lee
/*2)*/principales ::= declaracion:declare {: RESULT = declare.toString(); :}
                    | asignacion:asign {: RESULT = asign.toString(); :} //declara_asigna PENDIENTE
                    | escritura:write {: RESULT = write.toString(); :}
                    | lectura:read {: RESULT = read.toString(); :}
                    | llamada:call {: RESULT = call.toString(); :}
                    ;

        //No terminal: declara DUDA: ELIMINO ALIAS DE ENTERO, FLOAT...?
/*3*/ declaracion ::= ENTERO:entero NomVariable:nameVar {: guardarVariable("int",nameVar.toString()); RESULT = "int " + nameVar.toString() +";"; :}
                    | FLOTANTE:flotante NomVariable:nameVar {: guardarVariable("double",nameVar.toString()); RESULT = "double " + nameVar.toString()+";"; :}
                    | TEXTO:string NomVariable:nameVar {: guardarVariable("String",nameVar.toString()); RESULT = "String " + nameVar.toString()+";"; :}
                    ;
      
        //No terminal: asigna
/*4*/ asignacion ::= NomVariable:nameVar IGUAL numero:num{: RESULT = nameVar.toString() + " = " + num.toString() + ";"; :}
                | NomVariable:nameVar IGUAL Cadena:chain {: RESULT = nameVar.toString() + " = " + chain.toString() + ";"; :}
                | NomVariable:nameVar1 IGUAL NomVariable:nameVar2 {: RESULT = nameVar1.toString() + " = " + nameVar2.toString() + ";"; :}
                | NomVariable:nameVar IGUAL llamada:call {: RESULT = nameVar.toString() + " = " + call.toString(); :}
                ;

    numero ::= NumEntero:numInt {: RESULT = numInt.toString(); :}
        | NumDecimal:numDec {: RESULT = numDec.toString(); :}
        | operacion:operation {: RESULT = operation.toString(); :}
        ;

    operacion ::= NumEntero:numInt1 operando:op NumEntero:numInt2 {: RESULT = numInt1.toString() + op.toString() + numInt2.toString();  :}
                | NumEntero:numInt operando:op NomVariable:nameVar {: RESULT = numInt.toString() + op.toString() + nameVar.toString(); :}
                | NomVariable:nameVar1 operando:op NomVariable:nameVar2  {: RESULT = nameVar1.toString() + op.toString() + nameVar2.toString(); :}
                | NomVariable:nameVar operando:op NumEntero:numInt {: RESULT = nameVar.toString() + op.toString() + numInt.toString(); :}
                ;

    operando ::= MAS {: RESULT =  "+"; :}
                | MENOS {: RESULT = "-"; :}
                | POR {: RESULT = "*"; :}
                | DIV {: RESULT = "/"; :}
                ;

        //No terminal: escribe
/*5*/escritura ::= ESCRIBIR PAR_A mensaje:message PAR_C {: RESULT = "System.out.println(String.valueOf("+ message.toString() +"));"; :}
                ;

        mensaje ::= NomVariable:nameVar {: RESULT = nameVar.toString(); :}
                | Cadena:text {: RESULT = text.toString(); :}
                | llamada:call {: RESULT = call.toString(); :} //EXTRAAA
                ;

        //No terminal: lee
/*6*/lectura ::= LEER PAR_A NomVariable:nameVar  PAR_C {: String result = obtenerTipoVariable(nameVar.toString());
                        if(result.equals("int")){
                                RESULT = nameVar.toString() + " = " + "Integer.parseInt(JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\"));";
                        } else if(result.equals("double")){
                                RESULT = nameVar.toString() + " = " + "Double.parseDouble(JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\"));";
                        } else if(result.equals("String")){
                                RESULT = nameVar.toString() + " = " + "JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\");";
                        }
                        :}
                ;

        llamada ::= NomVariable:nameProcess PAR_A parametros_enviados:sent_params PAR_C {:  RESULT = nameProcess.toString() + "(" + recorrerArrParametrosEnviados(sent_params) + ");"; :}
                        | NomVariable:nameProcess PAR_A PAR_C PUNTO_COMA {: /*buscarFuncion(funcName.toString())*/; RESULT = nameProcess.toString() + "();"; :}
                        ;

        parametros_enviados ::= parametro_enviado:param  {: RESULT = new ArrayList<String>(); RESULT.add(param.toString()); :}
                        | parametros_enviados:params COMA parametro_enviado:param {: params.add("," + param.toString()); RESULT = params; :}
                        ;

        parametro_enviado ::= numerocadena:numchain {: RESULT = numchain.toString(); :}
                        | NumDecimal:flot {: RESULT = flot.toString(); :} 
                        | NomVariable:paramName {: RESULT = paramName.toString(); :}
                        ;


        //No terminal: condiciones
/*3)*/condicionales ::= si:iff  {: RESULT = iff.toString(); :}
                | si:iff sino:elsee {: RESULT = iff.toString() + elsee.toString(); :}
                | conmutador:switchh {: RESULT = switchh.toString(); :}
                ;

        //No terminal: if
/*7*/si ::= SI PAR_A condicion:condi PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "if(" + condi.toString() + "){" + recorrerArrInstrucciones(instr) + "}"; :}
        ;

    condicion ::= valor:val1 comparador:comp valor:val2 {: RESULT = val1.toString() + comp.toString() + val2.toString(); :}
                //| valor:val1 comparador:comp valor:val2 COMPARADOR condicion:cond1 {: RESULT = val1.toString() + comp.toString() + val2.toString() + "," + cond1.toString(); :}
                ; //FALTA LETRAS

    valor ::= NomVariable:nameVar {: RESULT = nameVar.toString(); :}
           | NumEntero:numInt {: RESULT = numInt.toString(); :}
           ;

    comparador ::= IGUAL IGUAL {: RESULT = "=="; :}
                | MAYOR {: RESULT = ">"; :}
                | MENOR {: RESULT = "<"; :}
                | MAYOR IGUAL {: RESULT = ">="; :}
                | MENOR IGUAL {: RESULT = "<="; :}
                | DIF IGUAL {: RESULT = "!="; :}
                ;
    
    instruc ::= tarea:exec {: RESULT = new ArrayList<String>(); RESULT.add(exec.toString()); :}
            | instruc:instr tarea:exec  {: instr.add(exec.toString()); RESULT = instr; :} //principales:princ PUNTO_COMA {: RESULT = princ.toString(); :}
            ; //declara,asigna,lee,escribe

        //No terminal: else
/*8*/sino ::= SINO LLAVE_A instruc:instr LLAVE_C {: RESULT =  "else{" + recorrerArrInstrucciones(instr) + "}"; :}
            ;

        //No terminal: Switch
/*9*/conmutador ::= EN_CASO_DE PAR_A NomVariable:nameVar PAR_C LLAVE_A casos:cases predeterminado:def /*FIN_EN_CASO_DE*/ LLAVE_C {: RESULT = "switch(" + nameVar + "){" + recorrerArrCasos(cases) + def.toString() + "}"; :}
                ;
        //No terminal: ArrayList<arrCasos>
        casos ::= casos:cases caso:casee {: cases.add(casee.toString()); RESULT = cases; :} //Aggrega el caso al array de casos
                | caso:casee {: RESULT = new ArrayList<String>(); RESULT.add(casee.toString()); :}
                ;
        //No terminal: Caso (singular) que arriba sera guardado en casos (ArrayList<casos>)
        caso ::= CASO numerocadena:numchain DOS_PUNTOS instruc:instr FIN_CASO {: RESULT = "case " + numchain.toString() + ":\n" + recorrerArrInstrucciones(instr) + "\nbreak;"; :}
        ;

        numerocadena ::= NumEntero:num {: RESULT = num.toString(); :} //solo num enteros
                | Cadena:text {: RESULT = text.toString(); :}
                ;
        
        predeterminado ::= DEPLANO DOS_PUNTOS instruc:instr FIN_CASO {: RESULT = "default:" + recorrerArrInstrucciones(instr) + "break;"; :}
                        ;


        //No terminal: ciclos
/*4)*/ciclos ::= para:forr {: RESULT = forr.toString(); :}
        | mientras:whilee {: RESULT = whilee.toString(); :}
        ;
        //No terminal> for
/*10*/para ::= PARA PAR_A param_para:par PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "for(" + par + "){" + recorrerArrInstrucciones(instr) + "}"; :}
            ;

    param_para ::= valor:val1 COMA valor:val2 {: RESULT = "int i=" + val1 + "; i<" + val2 + "; i++"; :}
                ;

        //No terminal: while
/*11*/mientras ::= MIENTRAS PAR_A condicion:condi PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "while(" + condi.toString() + "){" + recorrerArrInstrucciones(instr) + "}"; :}
                ;
