package menwic.interprete.analizadores.a_sintactico;

import menwic.interprete.analizadores.a_lexico.Lexer;
import java.util.ArrayList;
import javax.swing.JOptionPane;
import java_cup.runtime.*;

//class Parser;
parser code {:

    //Heap que almacena variables
    private ArrayList<Variable> arrVariables; //Heap que almacena variables
    private ArrayList<String> arrProcedimientos; //Heap que almacena Procedimientos
    private ArrayList<String> arrFunciones; //Heap que almacena Funciones
    //private javax.swing.JTextArea textArea;

    //Constructor
    public parser(Lexer lex, javax.swing.JTextArea text){ //Debo cambiar TextArea por clase Codigo? Yo consideor que no
        super(lex);
        this.arrVariables = new ArrayList<>(); //Arreglo
        this.arrProcedimientos = new ArrayList<>(); //Arreglo de los nombres de procedimientos
        this.arrFunciones = new ArrayList<>(); //Arreglo de los nombres de funciones
    }
     
     /*  */
        String texto = ""; //Texto que iremos acumulando para pasar a Java

        //Getter de txt
        public String getText() {
                return texto;
        }

        /* *************************************************************** */
        /*
        public void report_fatal_error(String message, Object info){
            System.out.println("Public void report_fatal_error");
        }

        public void syntax_error(Symbol cur_token){
            System.out.println("Error: "+cur_token.value.toString());
        }

        public void unrecoveres_syntax_error(Symbol cur_token){
            if(cur_token.sym==sym.EOF){
                System.out.println("Public void unrecoveredsyntax_Error");
            }
        }
        */
        /* ***************************************************************** */

        //Metodo que recorre el arreglo de casos de un Switch
        public String recorrerArrCasos(ArrayList<String> casos){
                String txt = "";
                for(String s : casos){
                        txt += s + "\n";
                }
                return txt;
        }

        //Metodo que recorre el arreglo de instrucciones de una ejecucion (condicion, ciclo o proceso)
        public String recorrerArrInstrucciones(ArrayList<String> instrucciones){
                String txt = "";
                for(String s : instrucciones){
                        txt += s + "\n";
                }
                return txt;
        }

        //Metodo para guardar variable al declararla
        public void guardarVariable(String dataType, String nameVar){
                arrVariables.add(new Variable(dataType,nameVar));
        }

        //Metodo para identificar tipo primitivo de la variable
        public String obtenerTipoVariable(String nameVar) {
                String resultado = "";
                Variable var = buscarVariable(nameVar);

                if (var != null) {
                        switch (var.getTipo()) {
                                case "int":
                                        return "int";
                                case "float":
                                        return "float";
                                case "String":
                                        return "String";
                        }
                } else {
                        System.out.println(var.getNombre() + " no fue encontrado como Variable.");
        }
        return resultado;
    }

        //Metodo para encontrar una variable declarada previamente
        public Variable buscarVariable(String nameVar){
                for(Variable var : arrVariables){
                        if(var.getNombre().equals(nameVar)){
                                return var;
                        }
                }
                return null;
        }

        /* ************************************************************************************************ */
        //Recorre parametros del arreglo global y elimina "_"
        public String recorrerParametros(ArrayList<String> arrParametros){
            String result = "";

            for(String p: arrParametros){
                result += p.replaceAll("_", " "); 
            }
            return result;
        }

        //Metodo para guardar procedimientos (nombre y parametros)
        public void guardarProcedimiento(String nameProcedure){
                arrProcedimientos.add(nameProcedure); //
        }

        //Metodo para guardar funciones (nombre, tipo, parametros)
        public void guardarFuncion(String dataType, String nameFunction){ //COMO HAGO POR EL TIPO, CONCATENADOS COMO UN STR???
                String func = dataType +"_"+ nameFunction;
                arrFunciones.add(func);
        }

        //Metodo para identificar tipo primitivo de la funcion
        //SIN USAR AUN, BORRAR
        /*
        public String obtenerTipoFuncion(String nameFunction) {
                String resultado = "";
                Funcion funct = buscarFunction(nameFunction);

                if (funct != null) {
                        switch (funct.getTipo()) {
                                case "int":
                                        return "int";
                                case "float":
                                        return "float";
                                case "String":
                                        return "String";
                        }
                } else {
                        System.out.println(var.getNombre() + " no fue encontrado como Funcion.");
            }
            return resultado;
        }
        /*
        /* ************************************************************************************************ */
:}


//terminals de flex
terminal IGUAL,MAS, MENOS, POR, DIV, DIF, MAYOR, MENOR, PAR_A, PAR_C, LLAVE_A, LLAVE_C, COMA, PUNTO_COMA, DOS_PUNTOS,
ENTERO, FLOTANTE, TEXTO, NumEntero, NumDecimal, NomVariable, Cadena,
ESCRIBIR, LEER, SI, SINO, EN_CASO_DE, CASO, FIN_CASO, DEPLANO, PARA, MIENTRAS, PROCEDIMIENTO, FUNCION, ERROR;

//no terminales de cup
non terminal inicio, preejecucion, proceso, procedimiento, param, funcion, tipoDato, ejecucion, tarea, principales, declaracion, asignacion, numero, operacion, operando, 
escritura, mensaje, lectura, condicionales, si, condicion, valor, comparador, sino, conmutador, numerocadena, caso, predeterminado,
ciclos, mientras, para, param_para;

non terminal ArrayList<String> parametros, casos, instruc; //no terminales de tipo ArrayList<String> para alamacenar Strings

        //Funciones/Procedimientos y Principales (ciclos,condicionales,principales) 
/*-0-*/inicio ::= preejecucion:preexec ejecucion:exec {: texto += preexec.toString() + exec.toString(); :}
                | ejecucion:exec {: texto += exec.toString(); :}
                ;


        //Funciones/Procedimientos recursivamente DUDA: ESTA BIEN ASI LA RECURSIVIDAD? O ES AL REVES?
/*-1-*/preejecucion ::= proceso:proc preejecucion:preexec {: RESULT = proc.toString() + preexec.toString() + "\n"; :}
                    | proceso:proc {: RESULT = proc.toString() + "\n"; :}
                    ;


        //No terminal: Procedimiento o Funcion
/*1)*/proceso ::= procedimiento:proced {: texto += proced.toString() + "\n"; :}
                | funcion:func {: texto += func.toString() + "\n"; :}
                ;

        //DUDA: los parametros:params cuando los guardo?
/*1*/procedimiento ::= PROCEDIMIENTO NomVariable:nameProced PAR_A parametros:params PAR_C LLAVE_A instruc:instr LLAVE_C {: guardarProcedimiento(nameProced.toString()); RESULT = "public static void " + nameProced.toString() + "(" + recorrerParametros(params) + "){" + recorrerArrInstrucciones(instr) + "}"; :}
                    | PROCEDIMIENTO NomVariable:nameProced PAR_A PAR_C LLAVE_A instruc:instr LLAVE_C {: guardarProcedimiento(nameProced.toString()); RESULT = "public static void " + nameProced.toString() + "(){" + recorrerArrInstrucciones(instr) + "}"; :}
                    ;

        //No terminal: Funcion con y sin parametros
/*2*/funcion ::= FUNCION tipoDato:dataType NomVariable:nameFunc PAR_A parametros:params PAR_C LLAVE_A instruc:instr LLAVE_C {: guardarFuncion(dataType.toString(), nameFunc.toString()); RESULT = "public static " + dataType.toString() + " " + nameFunc.toString() + "(" + recorrerParametros(params) + "){" + recorrerArrInstrucciones(instr) + "}"; :}
            | FUNCION tipoDato:dataType NomVariable:nameFunc PAR_A PAR_C LLAVE_A instruc:instr LLAVE_C {: guardarFuncion(dataType.toString(), nameFunc.toString()); RESULT = "public static " + dataType.toString() + " " + nameFunc.toString() + "(){" + recorrerArrInstrucciones(instr) + "}"; :}
            ;

    //DEBEN IR CONCATENADOS EL TIPO Y NOMBRE FUNC PARA GUARDAR EN ARRAYLIST??? 
    tipoDato ::= ENTERO {: RESULT = "int"; :}
            | FLOTANTE {: RESULT = "float"; :}
            | TEXTO {: RESULT = "String"; :}
            ;

    //No terminal: ArrayList<params>
    parametros ::= param:par {: RESULT = new ArrayList<>(); RESULT.add(par.toString()); :}
                | parametros:pars param:par {: pars.add(","+ par.toString()); RESULT = pars; :} 
                ;
    //No terminal: param (singular) que se guardara arriba en arrParametros (ArrayList<params>)
    param ::= ENTERO NomVariable:nameProcedure {: RESULT = "int_" + nameProcedure.toString(); :}
            | FLOTANTE NomVariable:nameProcedure {: RESULT= "float_" + nameProcedure.toString(); :}
            | TEXTO NomVariable:nameProcedure {: RESULT= "String_" + nameProcedure.toString(); :}
            ;


        //No terminal: principales, condiciones o ciclos
/*-2-*/ejecucion ::= tarea:task  {: /*RESULT = task.toString() + exec.toString() + "\n";*/ :} //ejecucion:exec
                    //| tarea:task {: /*RESULT = task.toString() + "\n";*/ :}
                    ; /* LE QUITE MULTILNEA PARA AREGLAR ERROR AL COMPILAR CUP, SI LO PONGO, HAY CONFLICTO
                         ENTRE ejecucion Y LAS PRODUCCIONES DE tarea */


/*-2.1-*/tarea ::= principales:princ PUNTO_COMA {: texto += princ.toString() + "\n"; :}
                    | condicionales:cond {: texto += cond.toString() + "\n"; :}
                    | ciclos:cycle {: texto += cycle.toString() + "\n"; :}
                    ;

        //No terminal: declara, asigna, escribe, lee
/*2)*/principales ::= declaracion:declare {: RESULT = declare.toString(); :}
                    | asignacion:asign {: RESULT = asign.toString(); :} //declara_asigna PENDIENTE
                    | escritura:write {: RESULT = write.toString(); :}
                    | lectura:read {: RESULT = read.toString(); :}
                    ;

        //No terminal: declara DUDA: ELIMINO ALIAS DE ENTERO, FLOAT...?
/*3*/ declaracion ::= ENTERO:entero NomVariable:nameVar {: guardarVariable("int",nameVar.toString()); RESULT = "int " + nameVar.toString() +";"; :}
                    | FLOTANTE:flotante NomVariable:nameVar {: guardarVariable("float",nameVar.toString()); RESULT = "float " + nameVar.toString()+";"; :}
                    | TEXTO:string NomVariable:nameVar {: guardarVariable("String",nameVar.toString()); RESULT = "String " + nameVar.toString()+";"; :}
                    ;
      
        //No terminal: asigna
/*4*/ asignacion ::= NomVariable:nameVar IGUAL Cadena:text {: RESULT = nameVar + " = " + text + ";"; :}
                | NomVariable:nameVar IGUAL numero:num {: RESULT = nameVar + " = " + num + ";"; :}
                ;

    numero ::= NumEntero:numInt {: RESULT = numInt.toString(); :}
        | NumDecimal:numDec {: RESULT = numDec.toString(); :}
        | operacion:operation {: RESULT = operation.toString(); :}
        ;

    operacion ::= NumEntero:numInt1 operando:op NumEntero:numInt2 {: RESULT = numInt1.toString() + op.toString() + numInt2.toString();  :}
                | NumEntero:numInt operando:op NomVariable:nameVar {: RESULT = numInt.toString() + op.toString() + nameVar.toString(); :}
                | NomVariable:nameVar1 operando:op NomVariable:nameVar2  {: RESULT = nameVar1.toString() + op.toString() + nameVar2.toString(); :}
                | NomVariable:nameVar operando:op NumEntero:numInt {: RESULT = nameVar.toString() + op.toString() + numInt.toString(); :}
                ;

    operando ::= MAS {: RESULT =  "+"; :}
                | MENOS {: RESULT = "-"; :}
                | POR {: RESULT = "*"; :}
                | DIV {: RESULT = "/"; :}
                ;

        //No terminal: escribe
/*5*/escritura ::= ESCRIBIR PAR_A mensaje:message PAR_C {: RESULT = "System.out.println(String.valueOf("+ message.toString() +"));"; :}
                ;

        mensaje ::= NomVariable:nameVar {: RESULT = nameVar; :}
                | Cadena:text {: RESULT = text; :}
                ;

        //No terminal: lee
/*6*/lectura ::= LEER PAR_A NomVariable:nameVar  PAR_C {: String result = obtenerTipoVariable(nameVar.toString());
                        if(result.equals("int")){
                                RESULT = nameVar.toString() + " = " + "Integer.parseInt(JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\"));";
                        } else if(result.equals("float")){
                                RESULT = nameVar.toString() + " = " + "Float.parseFloat(JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\"));";
                        } else if(result.equals("String")){
                                RESULT = nameVar.toString() + " = " + "JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\");";
                        }
                        :}
                ;


        //No terminal: condiciones
/*3)*/condicionales ::= si:iff  {: RESULT = iff.toString(); :}
                | si:iff sino:elsee {: RESULT = iff.toString() + elsee.toString(); :}
                | conmutador:switchh {: RESULT = switchh.toString(); :}
                ;

        //No terminal: if
/*7*/si ::= SI PAR_A condicion:condi PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "if(" + condi.toString() + "){" + recorrerArrInstrucciones(instr) + "}"; :}
        ;

    condicion ::= valor:val1 comparador:comp valor:val2 {: RESULT = val1.toString() + comp.toString() + val2.toString(); :}
                //| valor:val1 comparador:comp valor:val2 COMPARADOR condicion:cond1 {: RESULT = val1.toString() + comp.toString() + val2.toString() + "," + cond1.toString(); :}
                ; //FALTA LETRAS

    valor ::= NomVariable:nameVar {: RESULT = nameVar.toString(); :}
           | NumEntero:numInt {: RESULT = numInt.toString(); :}
           ;

    comparador ::= IGUAL IGUAL {: RESULT = "=="; :}
                | MAYOR {: RESULT = ">"; :}
                | MENOR {: RESULT = "<"; :}
                | MAYOR IGUAL {: RESULT = ">="; :}
                | MENOR IGUAL {: RESULT = "<="; :}
                | DIF IGUAL {: RESULT = "!="; :}
                ;
    
    instruc ::= ejecucion:exec {: RESULT = new ArrayList<String>(); RESULT.add(exec.toString()); :}
            | instruc:instr ejecucion:exec  {: instr.add(exec.toString()); RESULT = instr; :} //principales:princ PUNTO_COMA {: RESULT = princ.toString(); :}
            ; //declara,asigna,lee,escribe

        //No terminal: else
/*8*/sino ::= SINO LLAVE_A instruc:instr LLAVE_C {: RESULT =  "else{" + recorrerArrInstrucciones(instr) + "}"; :}
            ;

        //No terminal: Switch
/*9*/conmutador ::= EN_CASO_DE PAR_A NomVariable:nameVar PAR_C LLAVE_A casos:cases predeterminado:def /*FIN_EN_CASO_DE*/ LLAVE_C {: RESULT = "switch(" + nameVar + "){" + recorrerArrCasos(cases) + def.toString() + "}"; :}
                ;
        //No terminal: ArrayList<arrCasos>
        casos ::= casos:cases caso:casee {: cases.add(casee.toString()); RESULT = cases; :} //Aggrega el caso al array de casos
                | caso:casee {: RESULT = new ArrayList<String>(); RESULT.add(casee.toString()); :}
                ;
        //No terminal: Caso (singular) que arriba sera guardado en casos (ArrayList<casos>)
        caso ::= CASO numerocadena:numchain DOS_PUNTOS instruc:instr FIN_CASO {: RESULT = "case " + numchain.toString() + ":\n" + recorrerArrInstrucciones(instr) + "\nbreak;"; :}
        ;

        numerocadena ::= NumEntero:num {: RESULT = num.toString(); :} //solo num enteros
                | Cadena:text {: RESULT = text.toString(); :}
                ;
        
        predeterminado ::= DEPLANO DOS_PUNTOS instruc:instr FIN_CASO {: RESULT = "default:" + recorrerArrInstrucciones(instr) + "break;"; :}
                        ;


        //No terminal: ciclos
/*4)*/ciclos ::= para:forr {: RESULT = forr.toString(); :}
        | mientras:whilee {: RESULT = whilee.toString(); :}
        ;
        //No terminal> for
/*10*/para ::= PARA PAR_A param_para:par PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "for(" + par + "){" + recorrerArrInstrucciones(instr) + "}"; :}
            ;

    param_para ::= valor:val1 COMA valor:val2 {: RESULT = "int i=" + val1 + "; i<" + val2 + "; i++"; :}
                ;

        //No terminal: while
/*11*/mientras ::= MIENTRAS PAR_A condicion:condi PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "while(" + condi.toString() + "){" + recorrerArrInstrucciones(instr) + "}"; :}
                ;
