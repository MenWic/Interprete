package menwic.interprete.analizadores.a_sintactico;

import menwic.interprete.analizadores.a_lexico.Lexer;
import java.util.ArrayList;
import javax.swing.JOptionPane;
import java_cup.runtime.*;

//class Parser;
parser code {:

    //Heap que almacena variables
    private ArrayList<Variable> arrVariables;
    //private javax.swing.JTextArea textArea;


    public parser(Lexer lex, javax.swing.JTextArea text){ //Debo cambiar TextArea por clase Codigo? Yo consideor que no
        super(lex);
        this.arrVariables = new ArrayList<>();
        //this.arrPyF = newArrayList<>(); //Arreglo de los nombres de procedimientos y funciones declarados
    }
     
     /*  */
        String texto = ""; //Texto que iremos acumulando para pasar a Java

        //Getter de txt
        public String getText() {
                return texto;
        }

        //Metodo que recorre el arreglo de casos de un Switch
        public String recorrerArrCasos(ArrayList<String> casos){
                String txt = "";
                for(String s : casos){
                        txt += s + "\n";
                }
                return txt;
        }

        //Metodo que recorre el arreglo de casos de un Switch
        public String recorrerArrInstrucciones(ArrayList<String> instrucciones){
                String txt = "";
                for(String s : instrucciones){
                        txt += s + "\n";
                }
                return txt;
        }

        //Metodo para guardar variable al declararla
        public void guardarVariable(String dataType, String nameVar){
                arrVariables.add(new Variable(dataType,nameVar));
        }

        //Metodo para identificar tipo primitivo de la variable
        public String obtenerTipoVariable(String nameVar) {
                String resultado = "";
                Variable var = buscarVariable(nameVar);

                if (var != null) {
                        switch (var.getTipo()) {
                                case "int":
                                        return "int";
                                case "float":
                                        return "float";
                                case "String":
                                        return "String";
                        }
                } else {
                        System.out.println(var.getNombre() + " no fue encontrado como Variable.");
        }
        return resultado;
    }

        //Metodo para encontrar una variable declarada previamente
        public Variable buscarVariable(String nameVar){
                for(Variable var : arrVariables){
                        if(var.getNombre().equals(nameVar)){
                                return var;
                        }
                }
                return null;
        }
:}


//terminals de flex
terminal IGUAL,MAS, MENOS, POR, DIV, DIF, MAYOR, MENOR, PAR_A, PAR_C, LLAVE_A, LLAVE_C, COMA, PUNTO_COMA, DOS_PUNTOS,
ENTERO, FLOTANTE, TEXTO, NumEntero, NumDecimal, NomVariable, Cadena,
ESCRIBIR, LEER, SI, SINO, EN_CASO_DE, CASO, FIN_CASO, DEPLANO, PARA, MIENTRAS, ERROR;

//no terminales de cup
non terminal inicio, principales, ejecucion, declaracion, asignacion, numero, operacion, operando, escritura, mensaje, lectura, 
condicionales, si, condicion, valor, comparador, sino, conmutador, numerocadena, caso, predeterminado, mientras, ciclos, para, param; //tipo_dato

non terminal ArrayList<String> casos, instruc;

/*-0-*/
inicio ::= inicio ejecucion:exec {: texto += exec.toString(); :}
        | ejecucion:exec {: texto += exec.toString(); :}
        ;

/*-1-*/ ejecucion ::= principales:init PUNTO_COMA {: RESULT = init.toString() + "\n"; :}
                | condicionales:cond {: RESULT = cond.toString() + "\n"; :}
                | ciclos:cycle {: RESULT = cycle.toString() + "\n"; :}
                ;

/*1)*/principales ::= declaracion:declare {: RESULT = declare.toString(); :}
                | asignacion:asign {: RESULT = asign.toString(); :} //declara_asigna PENDIENTE
                | escritura:write {: RESULT = write.toString(); :}
                | lectura:read {: RESULT = read.toString(); :}
                ;


/*1*/ declaracion ::= ENTERO:entero NomVariable:nameVar {: guardarVariable("int",nameVar.toString()); RESULT = "int " + nameVar.toString() +";"; :}
                | FLOTANTE:flotante NomVariable:nameVar {: guardarVariable("float",nameVar.toString()); RESULT = "float " + nameVar.toString()+";"; :}
                | TEXTO:string NomVariable:nameVar {: guardarVariable("String",nameVar.toString()); RESULT = "String " + nameVar.toString()+";"; :}
                ;
      
/* PROBLEMA: VARIABLE = N + 1; DA PROBLEMA */
/*2*/ asignacion ::= NomVariable:nameVar IGUAL Cadena:text {: RESULT = nameVar + " = " + text + ";"; :}
                | NomVariable:nameVar IGUAL numero:num {: RESULT = nameVar + " = " + num + ";"; :}
                ;

    numero ::= NumEntero:numInt {: RESULT = numInt.toString(); :}
        | NumDecimal:numDec {: RESULT = numDec.toString(); :}
        | operacion:operation {: RESULT = operation.toString(); :}
        ;

    operacion ::= NumEntero:numInt1 operando:op NumEntero:numInt2 {: RESULT = numInt1.toString() + op.toString() + numInt2.toString();  :}
                | NumEntero:numInt operando:op NomVariable:nameVar {: RESULT = numInt.toString() + op.toString() + nameVar.toString(); :}
                | NomVariable:nameVar1 operando:op NomVariable:nameVar2  {: RESULT = nameVar1.toString() + op.toString() + nameVar2.toString(); :}
                | NomVariable:nameVar operando:op NumEntero:numInt {: RESULT = nameVar.toString() + op.toString() + numInt.toString(); :}
                ;

    operando ::= MAS {: RESULT =  "+"; :}
                | MENOS {: RESULT = "-"; :}
                | POR {: RESULT = "*"; :}
                | DIV {: RESULT = "/"; :}
                ;


/*3*/ escritura ::= ESCRIBIR PAR_A mensaje:message PAR_C {: RESULT = "System.out.println(String.valueOf("+ message.toString() +"));"; :}
                ;

        mensaje ::= NomVariable:nameVar {: RESULT = nameVar; :}
                | Cadena:text {: RESULT = text; :}
                ;


/*4*/ lectura ::= LEER PAR_A NomVariable:nameVar  PAR_C {: String result = obtenerTipoVariable(nameVar.toString());
                        if(result.equals("int")){
                                RESULT = nameVar.toString() + " = " + "Integer.parseInt(JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\"));";
                        } else if(result.equals("float")){
                                RESULT = nameVar.toString() + " = " + "Float.parseFloat(JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\"));";
                        } else if(result.equals("String")){
                                RESULT = nameVar.toString() + " = " + "JOptionPane.showInputDialog(null, \"Ingrese el nuevo valor para " + nameVar.toString() + ":\");";
                        }
                        :}
                ;


/*2)*/condicionales ::= si:iff  {: RESULT = iff.toString(); :}
                | si:iff sino:elsee {: RESULT = iff.toString() + elsee.toString(); :}
                | conmutador:switchh {: RESULT = switchh.toString(); :}
                ;


/*5*/ si ::= SI PAR_A condicion:condi PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "if(" + condi.toString() + "){" + recorrerArrInstrucciones(instr) + "}"; :}
        ;

    condicion ::= valor:val1 comparador:comp valor:val2 {: RESULT = val1.toString() + comp.toString() + val2.toString(); :}
                //| valor:val1 comparador:comp valor:val2 COMPARADOR condicion:cond1 {: RESULT = val1.toString() + comp.toString() + val2.toString() + "," + cond1.toString(); :}
                ; //FALTA LETRAS

    valor ::= NomVariable:nameVar {: RESULT = nameVar.toString(); :}
           | NumEntero:numInt {: RESULT = numInt.toString(); :}
           ;

    comparador ::= IGUAL IGUAL {: RESULT = "=="; :}
                | MAYOR {: RESULT = ">"; :}
                | MENOR {: RESULT = "<"; :}
                | MAYOR IGUAL {: RESULT = ">="; :}
                | MENOR IGUAL {: RESULT = "<="; :}
                | DIF IGUAL {: RESULT = "!="; :}
                ;
    
    instruc ::= ejecucion:exec {: RESULT = new ArrayList<String>(); RESULT.add(exec.toString()); :}
            | instruc:instr ejecucion:exec  {: instr.add(exec.toString()); RESULT = instr; :} //principales:princ PUNTO_COMA {: RESULT = princ.toString(); :}
            ; //declara,asigna,lee,escribe


/*6*/ sino ::= SINO LLAVE_A instruc:instr LLAVE_C {: RESULT =  "else{" + recorrerArrInstrucciones(instr) + "}"; :}
            ;


/*7*/conmutador ::= EN_CASO_DE PAR_A NomVariable:nameVar PAR_C LLAVE_A casos:cases predeterminado:def /*FIN_EN_CASO_DE*/ LLAVE_C {: RESULT = "switch(" + nameVar + "){" + recorrerArrCasos(cases) + def.toString() + "}"; :}
                ;

        casos ::= casos:cases caso:casee {: cases.add(casee.toString()); RESULT = cases; :} //Aggrega el caso al array de casos
                | caso:casee {: RESULT = new ArrayList<String>(); RESULT.add(casee.toString()); :}
                ;

        caso ::= CASO numerocadena:numchain DOS_PUNTOS instruc:instr FIN_CASO {: RESULT = "case " + numchain.toString() + ":\n" + recorrerArrInstrucciones(instr) + "\nbreak;"; :}
        ;

        numerocadena ::= NumEntero:num {: RESULT = num.toString(); :} //solo num enteros
                | Cadena:text {: RESULT = text.toString(); :}
                ;
        
        predeterminado ::= DEPLANO DOS_PUNTOS instruc:instr FIN_CASO {: RESULT = "default:" + recorrerArrInstrucciones(instr) + "break;"; :}
                        ;


/*3)*/ciclos ::= para:forr {: RESULT = forr.toString(); :}
        | mientras:whilee {: RESULT = whilee.toString(); :}
        ;

/*7*/para ::= PARA PAR_A param:par PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "for(" + par + "){" + recorrerArrInstrucciones(instr) + "}"; :}
            ;

    param ::= valor:val1 COMA valor:val2 {: RESULT = "int i=" + val1 + "; i<" + val2 + "; i++"; :}
            ;


/*8*/mientras ::= MIENTRAS PAR_A condicion:condi PAR_C LLAVE_A instruc:instr LLAVE_C {: RESULT = "while(" + condi.toString() + "){" + recorrerArrInstrucciones(instr) + "}"; :}
                ;